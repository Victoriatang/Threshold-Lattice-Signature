#include "intervaltest.h"
void intervalt1p(SecShare &a,SecShare bit[comp_bitsNum],ifstream &fin)
{
	SecShare r;
	int32_t temp;
	SecShare tempp;
	r.setSecShare(a.index,0,0,0);
	string data;
	stringstream is;
	int32_t str[2];
	for(int i=0;i<comp_bitsNum;i++)
	{
		if(fin.eof())
		{
			fin.clear();
			fin.seekg(0,ios::beg);
		}
		getline(fin,data);
		is.clear();
		is.str("");
		is.str(data);
		is>>str[0]>>str[1];
		bit[i].setSecShare(a.index,str[0],str[1],0);
		temp=1<<i;
		tempp.setSecShare(bit[i].index,bit[i].share,bit[i].MACshare,bit[i].delta);
		Secmulticon(tempp,temp); //the result is blow[i]*2^i
		Secadd(r,tempp); // the result is r+blow[i]*2^i

	}
	Secadd(a,r);
}
void intervalt1(SecShare &a,SecShare blow[comp_bitsNum],SecShare bhigh[comp_bitsNum],ifstream &fin)
{// a is need to be compared with c1 and c2, the  input is blow[comp_bitsNum],
	//the output a=b+rï¼Œ where r is generated by bits blow[comp_bitsNum], bhigh[comp_bitsNum]=blow[comp_bitsNum]
	SecShare r;
	int32_t temp;
	SecShare tempp;
	r.setSecShare(a.index,0,0,0);
	string data;
	stringstream is;
	int32_t str[2];
	for(int i=0;i<comp_bitsNum;i++)
	{
		if(fin.eof())
		{
			fin.clear();
			fin.seekg(0,ios::beg);
		}
		getline(fin,data);
		is.clear();
		is.str("");
		is.str(data);
		is>>str[0]>>str[1];
		blow[i].setSecShare(a.index,str[0],str[1],0);
		bhigh[i].setSecShare(a.index,str[0],str[1],0);
		temp=1<<i;
		tempp.setSecShare(blow[i].index,blow[i].share,blow[i].MACshare,blow[i].delta);
		Secmulticon(tempp,temp); //the result is blow[i]*2^i
		Secadd(r,tempp); // the result is r+blow[i]*2^i

	}
	Secadd(a,r); //the result is  a=a+r 
	
	//shared bits blow[i] & bhigh[i] are not be changed. a is changed, in the last phase, 
	//the new a will be compared with c1 and c2

}
// shares a is opened to be int c. 
//when boundhigh>c>bound we do intervalt2p; if c>=bound, secret is larger than bound; if c<bound
// then secret is smaller than bound. 
void intervalt2p(SecShare bit[comp_bitsNum],int32_t c,
SecShare aa[comp_bitsNum],SecShare bb[comp_bitsNum],SecShare cc[comp_bitsNum],
SecShare epsilonshare[comp_bitsNum],
SecShare deltashare[comp_bitsNum],ifstream &fin,ifstream &fin1)
{
	int32_t newbound=c-boundhigh;
	Bitltc1(newbound,bit,aa,bb,cc,epsilonshare,deltashare,fin,fin1);
}
void intervalt2(SecShare blow[comp_bitsNum],SecShare bhigh[comp_bitsNum],
int32_t c,int32_t c1,int32_t c2,
	SecShare aalow[comp_bitsNum],SecShare bblow[comp_bitsNum],SecShare cclow[comp_bitsNum],
	SecShare aahigh[comp_bitsNum],SecShare bbhigh[comp_bitsNum],SecShare cchigh[comp_bitsNum],
	SecShare epsilonsharelow[comp_bitsNum],SecShare deltasharelow[comp_bitsNum],
	SecShare epsilonsharehigh[comp_bitsNum],SecShare deltasharehigh[comp_bitsNum],ifstream &fin, ifstream &fin1)
{//lowbits[comp_bitsNum] hithbits[comp_bitsNum] are bit representations of int low and high.  Secshare blow[comp_bitsNum] & bhigh[comp_bitsNum] are generated shared bits used in 
//bitltc algorithm, and will be changed. 
	int32_t low=0,high=0;
	if(c>=c2)
	{
		//cout<<"the first case "<<endl;
		low=c-c2;
		high=c-c1;

	}
	if(c<=c1)
	{
		//cout<<"the second case "<<endl;
		low=c-c2+Q;
		high=c+Q-c1;
		

	}
	if(c1<c && c<c2)
	{
		//cout<<"the third case"<<endl;
		
		low=c-c1-1;
		high=c+Q-c2+1;
		//cout<<"low is "<<low<<endl;
		//cout<<"high is "<<high<<endl;
		
	}
	//cout<<"low is "<<low<<endl;
	//cout<<"high is "<<high<<endl;
	Bitltc1(low,blow,aalow,bblow,cclow,epsilonsharelow,deltasharelow,fin,fin1);
	Bitltc1(high,bhigh,aahigh,bbhigh,cchigh,epsilonsharehigh,deltasharehigh,fin,fin1); 
		//the two executions are independent.
}
//open epsilonshare & deltashare are int epsilon and int delta
void intervalt3p(SecShare aa[comp_bitsNum],SecShare bb[comp_bitsNum],SecShare cc[comp_bitsNum],int32_t epsilon[comp_bitsNum],
int32_t delta[comp_bitsNum])
{
	Bitltc2(aa,bb,cc,epsilon,delta);
}
void intervalt3(SecShare aalow[comp_bitsNum],SecShare bblow[comp_bitsNum],SecShare cclow[comp_bitsNum],
SecShare aahigh[comp_bitsNum],SecShare bbhigh[comp_bitsNum],
	SecShare cchigh[comp_bitsNum],
	int32_t epsilonlow[comp_bitsNum], int32_t	deltalow[comp_bitsNum],
	int32_t epsilonhigh[comp_bitsNum],int32_t deltahigh[comp_bitsNum])
{//aalow,bblow,cclow,aahigh,bbhigh,cchigh,epsilonlow,deltalow,epsilonhigh,deltahigh are used for bitltc
	Bitltc2(aalow,bblow,cclow,epsilonlow,deltalow);
	Bitltc2(aahigh,bbhigh,cchigh,epsilonhigh,deltahigh);
}
//open aalow is int mlow; open aahigh is int mhigh
void intervalt4p(int32_t c,SecShare &s,SecShare &onebit,SecShare bit[comp_bitsNum],
int32_t m[comp_bitsNum],ifstream &fin,ifstream &finb)
{
	int32_t newbound=c-boundhigh;
	Bitltc3(newbound,s,onebit,bit,m,fin,finb);
}
void intervalt4(
SecShare &slow,SecShare &shigh,SecShare &bitlow,SecShare &bithigh,int32_t c,int32_t c1,int32_t c2,
	SecShare blow[comp_bitsNum],SecShare bhigh[comp_bitsNum],int32_t mlow[comp_bitsNum],int32_t mhigh[comp_bitsNum],ifstream &fin,ifstream &finb)
{//lowbits,highbits are bits of low & high, slow & shigh, bitlow & bithigh will be the output of bitltc3 or bitltc3minus, while blow[comp_bitsNum]
	//bhigh[comp_bitsNum] mlow[comp_bitsNum] & mhigh[comp_bitsNum] will be the input of bitltc3 or bitltc3minus.
 	int32_t low=0,high=0;
	if(c>=c2)
	{
		//cout<<"the first case "<<endl;
		low=c-c2;
		high=c-c1;

	}
	if(c<=c1)
	{
		//cout<<"the second case "<<endl;
		low=c-c2+Q;
		high=c+Q-c1;
		

	}
	if(c1<c && c<c2)
	{
		//cout<<"the third case"<<endl;
		
		low=c-c1-1;
		high=c+Q-c2+1;
		//cout<<"low is "<<low<<endl;
		//cout<<"high is "<<high<<endl;
		
	}
	 Bitltc3(low,slow,bitlow,blow,mlow,fin,finb);
 	Bitltc3minus(high,shigh,bithigh,bhigh,mhigh,fin,finb);
}
//open slow is int clow, open shigh is int chigh
void intervalt5p(int32_t splusb, SecShare &onebit)
{
	Bitltc4(splusb,onebit);
}
void intervalt5(int32_t clow,int32_t chigh,SecShare &bitlow,SecShare &bithigh,
SecShare &secsharea,SecShare &secshareb,SecShare &secsharec,
	SecShare &epsilonshare,SecShare &deltashare,ifstream &fin)
{//clow,chigh bitlow bithigh are used for bitltc4,the output is set in bitlow & bithigh
	// a,b,c,epsilonshare,deltashare,fin are used to compute bitlow * bithigh
	Bitltc4(clow,bitlow);
	Bitltc4(chigh,bithigh);
	multiply1(bitlow,bithigh,secsharea,secshareb,secsharec,epsilonshare,deltashare,fin);
	//cout<<"bitlow is "<<bitlow.share<<endl;
	//cout<<"bithigh is "<<bithigh.share<<endl;

}
// epsilonshare & deltashare are opened to be epsilon and delta
void intervalt6(int32_t c, int32_t c1,int32_t c2,SecShare &secsharea,SecShare &secshareb,SecShare &secsharec,int32_t epsilon,int32_t delta)
{// a,b,c,epsilon,delta are input for multiply, the result is set on a.
	multiply2(secsharea,secshareb,secsharec,epsilon,delta);// the result is secsharea
	//cout<<secsharea.share<<endl;
	if(c1<c && c<c2)
	{
		//cout<<"the thrid case "<<endl;
		Secmulticon(secsharea,-1);//the result is -a
		Secaddcon(secsharea,1);//the result is 1-a
	}
}